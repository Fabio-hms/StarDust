Diagrama:
stateDiagram-v2
    [*] --> q0
    q0 --> q1: [a-z_]
    q1 --> q1: [a-zA-Z0-9_]
    q1 --> [*]: Fim

Regex: [+-]?\d+


stateDiagram-v2
    [*] --> q0
    q0 --> q1: [+-]
    q0 --> q2: [0-9]
    q1 --> q2: [0-9]
    q2 --> q2: [0-9]
    q2 --> [*]: Fim

Regex: [+-]?(\d+\.\d*|\.\d+)([eE][+-]?\d+)?


stateDiagram-v2
    [*] --> q0
    q0 --> q1: [+-]
    q0 --> q2: [0-9]
    q0 --> q3: "."
    q1 --> q2: [0-9]
    q1 --> q3: "."
    q2 --> q2: [0-9]
    q2 --> q4: "."
    q3 --> q5: [0-9]
    q4 --> q5: [0-9]
    q5 --> q5: [0-9]
    q5 --> q6: [eE]
    q6 --> q7: [+-]
    q6 --> q8: [0-9]
    q7 --> q8: [0-9]
    q8 --> q8: [0-9]
    q8 --> [*]: Fim
    q5 --> [*]: Fim

Regex: '([^'\\]|\\.)*'


stateDiagram-v2
    [*] --> q0
    q0 --> q1: "'"
    q1 --> q1: caractere ≠ ' e ≠ \
    q1 --> q2: "\"
    q2 --> q1: qualquer caractere
    q1 --> qf: "'"
    qf --> [*]: Fim

Regex: "([^"\\]|\\.)*"


stateDiagram-v2
    [*] --> q0
    q0 --> q1: '"'
    q1 --> q1: caractere ≠ " e ≠ \
    q1 --> q2: "\"
    q2 --> q1: qualquer caractere
    q1 --> qf: '"'
    qf --> [*]: Fim

Regex: "=="


stateDiagram-v2
    [*] --> q0
    q0 --> q1: "="
    q1 --> q2: "="
    q2 --> [*]: Fim
(outros operadores seguem a mesma lógica: !=, >=, <=, >, <, =, +, -, *, /, //, %)


Regex: "("


stateDiagram-v2
    [*] --> q0
    q0 --> q1: "("
    q1 --> [*]: Fim
(idem para ), {, }, ;)


Linha (\...)

stateDiagram-v2
    [*] --> q0
    q0 --> q1: "\"
    q1 --> q1: caractere ≠ "\n"
    q1 --> [*]: fim da linha

Bloco (/* ... */)

stateDiagram-v2
    [*] --> q0
    q0 --> q1: "/"
    q1 --> q2: "*"
    q2 --> q2: caractere ≠ "*"
    q2 --> q3: "*"
    q3 --> q2: caractere ≠ "/"
    q3 --> qf: "/"
    qf --> [*]: Fim

Implementação:
import re

class AFD:
    def __init__(self, nome, padrao):
        self.nome = nome
        self.regex = re.compile(padrao)

    def reconhecer(self, texto):
        """Retorna o token reconhecido ou None se não casar."""
        match = self.regex.match(texto)
        if match:
            return (self.nome, match.group())
        return None


afd_identificador = AFD("IDENTIFICADOR", r"[a-z_][a-zA-Z0-9_]*")
afd_inteiro       = AFD("NUM_INTEIRO", r"[+-]?\d+")
afd_decimal       = AFD("NUM_DECIMAL", r"[+-]?(?:\d+\.\d*|\.\d+)(?:[eE][+-]?\d+)?")
afd_string_simples= AFD("STRING", r"'([^'\\]|\\.)*'")
afd_string_duplas = AFD("STRING", r'"([^"\\]|\\.)*"')

afd_igualdade     = AFD("OP_IGUAL", r"==")
afd_diferente     = AFD("OP_DIF", r"!=")
afd_maiorigual    = AFD("OP_GE", r">=")
afd_menorigual    = AFD("OP_LE", r"<=")
afd_maior         = AFD("OP_GT", r">")
afd_menor         = AFD("OP_LT", r"<")
afd_atribuicao    = AFD("OP_ATR", r"=")
afd_soma          = AFD("OP_ADD", r"\+")
afd_sub           = AFD("OP_SUB", r"-")
afd_mul           = AFD("OP_MUL", r"\*")
afd_div           = AFD("OP_DIV", r"/")
afd_divint        = AFD("OP_DIVINT", r"//")
afd_mod           = AFD("OP_MOD", r"%")

afd_par_esq       = AFD("DEL_PAR_ESQ", r"\(")
afd_par_dir       = AFD("DEL_PAR_DIR", r"\)")
afd_chave_esq     = AFD("DEL_CH_ESQ", r"\{")
afd_chave_dir     = AFD("DEL_CH_DIR", r"\}")
afd_ponto_virg    = AFD("DEL_PV", r";")

afd_coment_linha  = AFD("COMENT_LINHA", r"\\.*")
afd_coment_bloco  = AFD("COMENT_BLOCO", r"/\*.*?\*/")

afd_keywords = [AFD("KW_IF", r"\bif\b"),
                AFD("KW_ELSE", r"\belse\b"),
                AFD("KW_FOR", r"\bfor\b"),
                AFD("KW_WHILE", r"\bwhile\b"),
                AFD("KW_DEF", r"\bdef\b"),
                AFD("KW_RETURN", r"\breturn\b"),
                AFD("KW_TRUE", r"\btrue\b"),
                AFD("KW_FALSE", r"\bfalse\b"),
                AFD("KW_NULL", r"\bnull\b"),
                AFD("KW_AND", r"\band\b"),
                AFD("KW_OR", r"\bor\b"),
                AFD("KW_FUNCTION", r"\bfunction\b")]
                
Testes:
entrada = "if x >= 10 return y"
tokens = []
pos = 0

while pos < len(entrada):
    trecho = entrada[pos:]
    encontrado = None
    for afd in [afd_identificador, afd_inteiro, afd_decimal,
                afd_string_simples, afd_string_duplas,
                afd_igualdade, afd_diferente, afd_maiorigual, afd_menorigual,
                afd_maior, afd_menor, afd_atribuicao, afd_soma, afd_sub, afd_mul, afd_div, afd_divint, afd_mod,
                afd_par_esq, afd_par_dir, afd_chave_esq, afd_chave_dir, afd_ponto_virg,
                afd_coment_linha, afd_coment_bloco] + afd_keywords:
        token = afd.reconhecer(trecho)
        if token:
            tokens.append(token)
            pos += len(token[1])
            encontrado = True
            break
    if not encontrado:
        pos += 1  # ignora espaços ou caracteres inválidos

print(tokens)
